// c_backend_showcase.fuse â€” compiles to C with ADTs/match/traits/generics

type Option[T] = Some(T) | None

trait Ord[T] {
  fn lt(T, T) -> Bool
}

impl Ord[Int] {
  fn lt(a, b) = a < b
}

// Generic max specialized to concrete types at call-sites
fn max[T](a: T, b: T) -> T where Ord[T] =
  if Ord.lt[T](a, b) { b } else { a };

// A monomorphic helper
fn describe_int(o: Option[Int]) -> Str =
  match o {
    Some(x) -> "some",
    None    -> "none",
  };

fn add_ref(x: &Int, y: &Int) -> Int = x + y;

// Entry points we will call from C (monomorphic)
fn entry_calc(a: Int, b: Int) -> Int = max(a, b);

fn entry_opt(flag: Bool) -> Option[Int] =
  if flag { Some(42) } else { None() };

fn entry_describe(flag: Bool) -> Str = describe_int(entry_opt(flag));

fn entry_refs(a: Int, b: Int) -> Int = add_ref(&a, &b);
